(window.webpackJsonp=window.webpackJsonp||[]).push([[132],{571:function(n,r,t){"use strict";t.r(r),r.default="# 拖拽的实现\r\n\r\n本篇通过介绍一个实现拖拽的小例子来介绍如何在 Apache ECharts<sup>TM</sup> 中实现复杂的交互。\r\n\r\n<md-example src=\"line-draggable\" height=\"400\"></md-example>\r\n\r\n这个例子主要做到了这样一件事，用鼠标可以拖拽曲线的点，从而改变曲线的形状。例子很简单，但是有了这个基础我们还可以做更多的事情，比如在图中进行可视化得编辑。所以我们从这个简单的例子开始。\r\n\r\necharts 本身没有提供封装好的“拖拽改变图表”这样比较业务定制的功能。但是这个功能开发者可以通过 API 扩展实现。\r\n\r\n## 实现基本的拖拽功能\r\n\r\n在这个例子中，基础的图表是一个 [折线图 (series-line)](${optionPath}series-line)。参见如下配置：\r\n\r\n```js\r\nvar symbolSize = 20;\r\n\r\n// 这个 data 变量在这里单独声明，在后面也会用到。\r\nvar data = [\r\n  [15, 0],\r\n  [-50, 10],\r\n  [-56.5, 20],\r\n  [-46.5, 30],\r\n  [-22.1, 40]\r\n];\r\n\r\nmyChart.setOption({\r\n  xAxis: {\r\n    min: -100,\r\n    max: 80,\r\n    type: 'value',\r\n    axisLine: { onZero: false }\r\n  },\r\n  yAxis: {\r\n    min: -30,\r\n    max: 60,\r\n    type: 'value',\r\n    axisLine: { onZero: false }\r\n  },\r\n  series: [\r\n    {\r\n      id: 'a',\r\n      type: 'line',\r\n      smooth: true,\r\n      symbolSize: symbolSize, // 为了方便拖拽，把 symbolSize 尺寸设大了。\r\n      data: data\r\n    }\r\n  ]\r\n});\r\n```\r\n\r\n既然折线中原生的点没有拖拽功能，我们就为它加上拖拽功能：用 [graphic](${optionPath}graphic) 组件，在每个点上面，覆盖一个隐藏的可拖拽的圆点。\r\n\r\n```js\r\nmyChart.setOption({\r\n  // 声明一个 graphic component，里面有若干个 type 为 'circle' 的 graphic elements。\r\n  // 这里使用了 echarts.util.map 这个帮助方法，其行为和 Array.prototype.map 一样，但是兼容 es5 以下的环境。\r\n  // 用 map 方法遍历 data 的每项，为每项生成一个圆点。\r\n  graphic: echarts.util.map(data, function(dataItem, dataIndex) {\r\n    return {\r\n      // 'circle' 表示这个 graphic element 的类型是圆点。\r\n      type: 'circle',\r\n\r\n      shape: {\r\n        // 圆点的半径。\r\n        r: symbolSize / 2\r\n      },\r\n      // 用 transform 的方式对圆点进行定位。position: [x, y] 表示将圆点平移到 [x, y] 位置。\r\n      // 这里使用了 convertToPixel 这个 API 来得到每个圆点的位置，下面介绍。\r\n      position: myChart.convertToPixel('grid', dataItem),\r\n\r\n      // 这个属性让圆点不可见（但是不影响他响应鼠标事件）。\r\n      invisible: true,\r\n      // 这个属性让圆点可以被拖拽。\r\n      draggable: true,\r\n      // 把 z 值设得比较大，表示这个圆点在最上方，能覆盖住已有的折线图的圆点。\r\n      z: 100,\r\n      // 此圆点的拖拽的响应事件，在拖拽过程中会不断被触发。下面介绍详情。\r\n      // 这里使用了 echarts.util.curry 这个帮助方法，意思是生成一个与 onPointDragging\r\n      // 功能一样的新的函数，只不过第一个参数永远为此时传入的 dataIndex 的值。\r\n      ondrag: echarts.util.curry(onPointDragging, dataIndex)\r\n    };\r\n  })\r\n});\r\n```\r\n\r\n上面的代码中，使用 [convertToPixel](api.html#echartsInstance.convertToPixel) 这个 API，进行了从 data 到“像素坐标”的转换，从而得到了每个圆点应该在的位置，从而能绘制这些圆点。`myChart.convertToPixel('grid', dataItem)` 这句话中，第一个参数 `'grid'` 表示 `dataItem` 在 [grid](${optionPath}grid) 这个组件中（即直角坐标系）中进行转换。所谓“像素坐标”，就是以 echarts 容器 dom element 的左上角为零点的以像素为单位的坐标系中的坐标。\r\n\r\n注意这件事需要在第一次 setOption 后再进行，也就是说，须在坐标系（[grid](${optionPath}grid)）初始化后才能调用 `myChart.convertToPixel('grid', dataItem)`。\r\n\r\n有了这段代码后，就有了诸个能拖拽的点。接下来要为每个点，加上拖拽响应的事件：\r\n\r\n```js\r\n// 拖拽某个圆点的过程中会不断调用此函数。\r\n// 此函数中会根据拖拽后的新位置，改变 data 中的值，并用新的 data 值，重绘折线图，从而使折线图同步于被拖拽的隐藏圆点。\r\nfunction onPointDragging(dataIndex) {\r\n  // 这里的 data 就是本文最初的代码块中声明的 data，在这里会被更新。\r\n  // 这里的 this 就是被拖拽的圆点。this.position 就是圆点当前的位置。\r\n  data[dataIndex] = myChart.convertFromPixel('grid', this.position);\r\n  // 用更新后的 data，重绘折线图。\r\n  myChart.setOption({\r\n    series: [\r\n      {\r\n        id: 'a',\r\n        data: data\r\n      }\r\n    ]\r\n  });\r\n}\r\n```\r\n\r\n上面的代码中，使用了 [convertFromPixel](${mainSitePath}/api.html#echartsInstance.convertFromPixel) 这个 API。它是 [convertToPixel](${mainSitePath}/api.html#echartsInstance.convertToPixel) 的逆向过程。`myChart.convertFromPixel('grid', this.position)` 表示把当前像素坐标转换成 [grid](${optionPath}grid) 组件中直角坐标系的 dataItem 值。\r\n\r\n最后，为了使 dom 尺寸改变时，图中的元素能自适应得变化，加上这些代码：\r\n\r\n```js\r\nwindow.addEventListener('resize', function() {\r\n  // 对每个拖拽圆点重新计算位置，并用 setOption 更新。\r\n  myChart.setOption({\r\n    graphic: echarts.util.map(data, function(item, dataIndex) {\r\n      return {\r\n        position: myChart.convertToPixel('grid', item)\r\n      };\r\n    })\r\n  });\r\n});\r\n```\r\n\r\n## 添加 tooltip 组件\r\n\r\n到此，拖拽的基本功能就完成了。但是想要更进一步得实时看到拖拽过程中，被拖拽的点的 data 值的变化状况，我们可以使用 [tooltip](${optionPath}tooltip) 组件来实时显示这个值。但是，tooltip 有其默认的“显示”“隐藏”触发规则，在我们拖拽的场景中并不适用，所以我们还要手动定制 tooltip 的“显示”“隐藏”行为。\r\n\r\n在上述代码中分别添加如下定义：\r\n\r\n```js\r\nmyChart.setOption({\r\n  // ...,\r\n  tooltip: {\r\n    // 表示不使用默认的“显示”“隐藏”触发规则。\r\n    triggerOn: 'none',\r\n    formatter: function(params) {\r\n      return (\r\n        'X: ' +\r\n        params.data[0].toFixed(2) +\r\n        '<br>Y: ' +\r\n        params.data[1].toFixed(2)\r\n      );\r\n    }\r\n  }\r\n});\r\n```\r\n\r\n```js\r\nmyChart.setOption({\r\n  graphic: data.map(function(item, dataIndex) {\r\n    return {\r\n      type: 'circle',\r\n      // ...,\r\n      // 在 mouseover 的时候显示，在 mouseout 的时候隐藏。\r\n      onmousemove: echarts.util.curry(showTooltip, dataIndex),\r\n      onmouseout: echarts.util.curry(hideTooltip, dataIndex)\r\n    };\r\n  })\r\n});\r\n\r\nfunction showTooltip(dataIndex) {\r\n  myChart.dispatchAction({\r\n    type: 'showTip',\r\n    seriesIndex: 0,\r\n    dataIndex: dataIndex\r\n  });\r\n}\r\n\r\nfunction hideTooltip(dataIndex) {\r\n  myChart.dispatchAction({\r\n    type: 'hideTip'\r\n  });\r\n}\r\n```\r\n\r\n这里使用了 [dispatchAction](api.html#echartsInstance.dispatchAction) 来显示隐藏 tooltip。用到了 [showTip](api.html#action.tooltip.showTip)、[hideTip](api.html#action.tooltip.hideTip)。\r\n\r\n## 全部代码\r\n\r\n总结一下，全部的代码如下：\r\n\r\n```js\r\nimport echarts from 'echarts';\r\n\r\nvar symbolSize = 20;\r\nvar data = [\r\n  [15, 0],\r\n  [-50, 10],\r\n  [-56.5, 20],\r\n  [-46.5, 30],\r\n  [-22.1, 40]\r\n];\r\nvar myChart = echarts.init(document.getElementById('main'));\r\nmyChart.setOption({\r\n  tooltip: {\r\n    triggerOn: 'none',\r\n    formatter: function(params) {\r\n      return (\r\n        'X: ' +\r\n        params.data[0].toFixed(2) +\r\n        '<br />Y: ' +\r\n        params.data[1].toFixed(2)\r\n      );\r\n    }\r\n  },\r\n  xAxis: { min: -100, max: 80, type: 'value', axisLine: { onZero: false } },\r\n  yAxis: { min: -30, max: 60, type: 'value', axisLine: { onZero: false } },\r\n  series: [\r\n    { id: 'a', type: 'line', smooth: true, symbolSize: symbolSize, data: data }\r\n  ]\r\n});\r\nmyChart.setOption({\r\n  graphic: echarts.util.map(data, function(item, dataIndex) {\r\n    return {\r\n      type: 'circle',\r\n      position: myChart.convertToPixel('grid', item),\r\n      shape: { r: symbolSize / 2 },\r\n      invisible: true,\r\n      draggable: true,\r\n      ondrag: echarts.util.curry(onPointDragging, dataIndex),\r\n      onmousemove: echarts.util.curry(showTooltip, dataIndex),\r\n      onmouseout: echarts.util.curry(hideTooltip, dataIndex),\r\n      z: 100\r\n    };\r\n  })\r\n});\r\nwindow.addEventListener('resize', function() {\r\n  myChart.setOption({\r\n    graphic: echarts.util.map(data, function(item, dataIndex) {\r\n      return { position: myChart.convertToPixel('grid', item) };\r\n    })\r\n  });\r\n});\r\nfunction showTooltip(dataIndex) {\r\n  myChart.dispatchAction({\r\n    type: 'showTip',\r\n    seriesIndex: 0,\r\n    dataIndex: dataIndex\r\n  });\r\n}\r\nfunction hideTooltip(dataIndex) {\r\n  myChart.dispatchAction({ type: 'hideTip' });\r\n}\r\nfunction onPointDragging(dataIndex, dx, dy) {\r\n  data[dataIndex] = myChart.convertFromPixel('grid', this.position);\r\n  myChart.setOption({\r\n    series: [\r\n      {\r\n        id: 'a',\r\n        data: data\r\n      }\r\n    ]\r\n  });\r\n}\r\n```\r\n\r\n有了这些基础，就可以定制更多的功能了。可以加 [dataZoom](${optionPath}dataZoom) 组件，可以制作一个直角坐标系上的绘图板等等。可以发挥想象力。\r\n"}}]);