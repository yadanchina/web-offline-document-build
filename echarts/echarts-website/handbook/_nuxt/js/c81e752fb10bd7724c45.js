(window.webpackJsonp=window.webpackJsonp||[]).push([[99],{538:function(r,n,e){"use strict";e.r(n),n.default="# 使用 transform 进行数据转换\r\n\r\nApache ECharts<sup>TM</sup> 5 开始支持了“数据转换”（ data transform ）功能。在 echarts 中，“数据转换” 这个词指的是，给定一个已有的“数据集”（[dataset](${optionPath}#dataset)）和一个“转换方法”（[transform](${optionPath}#dataset.transform)），echarts 能生成一个新的“数据集”，然后可以使用这个新的“数据集”绘制图表。这些工作都可以声明式地完成。\r\n\r\n抽象地来说，数据转换是这样一种公式：`outData = f(inputData)`。`f` 是转换方法，例如：`filter`、`sort`、`regression`、`boxplot`、`cluster`、`aggregate`(todo) 等等。有了数据转换能力后，我们就至少可以做到这些事情：\r\n\r\n- 把数据分成多份用不同的饼图展现。\r\n- 进行一些数据统计运算，并展示结果。\r\n- 用某些数据可视化算法处理数据，并展示结果。\r\n- 数据排序。\r\n- 去除或直选择数据项。\r\n- ...\r\n\r\n## 数据转换基础使用\r\n\r\n在 echarts 中，数据转换是依托于数据集（[dataset](${optionPath}#dataset)）来实现的. 我们可以设置 [dataset.transform](${optionPath}#dataset.transform) 来表示，此 dataset 的数据，来自于此 transform 的结果。\r\n\r\n下面是上述例子的效果，三个饼图分别显示了 2011、2012、2013 年的数据。\r\n\r\n```js live\r\nvar option = {\r\n  dataset: [\r\n    {\r\n      // 这个 dataset 的 index 是 `0`。\r\n      source: [\r\n        ['Product', 'Sales', 'Price', 'Year'],\r\n        ['Cake', 123, 32, 2011],\r\n        ['Cereal', 231, 14, 2011],\r\n        ['Tofu', 235, 5, 2011],\r\n        ['Dumpling', 341, 25, 2011],\r\n        ['Biscuit', 122, 29, 2011],\r\n        ['Cake', 143, 30, 2012],\r\n        ['Cereal', 201, 19, 2012],\r\n        ['Tofu', 255, 7, 2012],\r\n        ['Dumpling', 241, 27, 2012],\r\n        ['Biscuit', 102, 34, 2012],\r\n        ['Cake', 153, 28, 2013],\r\n        ['Cereal', 181, 21, 2013],\r\n        ['Tofu', 395, 4, 2013],\r\n        ['Dumpling', 281, 31, 2013],\r\n        ['Biscuit', 92, 39, 2013],\r\n        ['Cake', 223, 29, 2014],\r\n        ['Cereal', 211, 17, 2014],\r\n        ['Tofu', 345, 3, 2014],\r\n        ['Dumpling', 211, 35, 2014],\r\n        ['Biscuit', 72, 24, 2014]\r\n      ]\r\n      // id: 'a'\r\n    },\r\n    {\r\n      // 这个 dataset 的 index 是 `1`。\r\n      // 这个 `transform` 配置，表示，此 dataset 的数据，来自于此 transform 的结果。\r\n      transform: {\r\n        type: 'filter',\r\n        config: { dimension: 'Year', value: 2011 }\r\n      }\r\n      // 我们还可以设置这些可选的属性： `fromDatasetIndex` 或 `fromDatasetId`。\r\n      // 这些属性，指定了，transform 的输入，来自于哪个 dataset。例如，\r\n      // `fromDatasetIndex: 0` 表示输入来自于 index 为 `0` 的 dataset 。又例如，\r\n      // `fromDatasetId: 'a'` 表示输入来自于 `id: 'a'` 的 dataset。\r\n      // 当这些属性都不指定时，默认认为，输入来自于 index 为 `0` 的 dataset 。\r\n    },\r\n    {\r\n      // 这个 dataset 的 index 是 `2`。\r\n      // 同样，这里因为 `fromDatasetIndex` 和 `fromDatasetId` 都没有被指定，\r\n      // 那么输入默认来自于 index 为 `0` 的 dataset 。\r\n      transform: {\r\n        // 这个类型为 \"filter\" 的 transform 能够遍历并筛选出满足条件的数据项。\r\n        type: 'filter',\r\n        // 每个 transform 如果需要有配置参数的话，都须配置在 `config` 里。\r\n        // 在这个 \"filter\" transform 中，`config` 用于指定筛选条件。\r\n        // 下面这个筛选条件是：选出维度（ dimension ）'Year' 中值为 2012 的所有\r\n        // 数据项。\r\n        config: { dimension: 'Year', value: 2012 }\r\n      }\r\n    },\r\n    {\r\n      // 这个 dataset 的 index 是 `3`。\r\n      transform: {\r\n        type: 'filter',\r\n        config: { dimension: 'Year', value: 2013 }\r\n      }\r\n    }\r\n  ],\r\n  series: [\r\n    {\r\n      type: 'pie',\r\n      radius: 50,\r\n      center: ['25%', '50%'],\r\n      // 这个饼图系列，引用了 index 为 `1` 的 dataset 。也就是，引用了上述\r\n      // 2011 年那个 \"filter\" transform 的结果。\r\n      datasetIndex: 1\r\n    },\r\n    {\r\n      type: 'pie',\r\n      radius: 50,\r\n      center: ['50%', '50%'],\r\n      datasetIndex: 2\r\n    },\r\n    {\r\n      type: 'pie',\r\n      radius: 50,\r\n      center: ['75%', '50%'],\r\n      datasetIndex: 3\r\n    }\r\n  ]\r\n};\r\n```\r\n\r\n现在我们简单总结下，使用 transform 时的几个要点：\r\n\r\n- 在一个空的 dataset 中声明 `transform`, `fromDatasetIndex`/`fromDatasetId` 来表示我们要生成新的数据。\r\n- 系列引用这个 dataset 。\r\n\r\n## 数据转换的进阶使用\r\n\r\n#### 链式声明 transform\r\n\r\n`transform` 可以被链式声明，这是一个语法糖。\r\n\r\n```js\r\noption = {\r\n  dataset: [\r\n    {\r\n      source: [\r\n        // 原始数据\r\n      ]\r\n    },\r\n    {\r\n      // 几个 transform 被声明成 array ，他们构成了一个链，\r\n      // 前一个 transform 的输出是后一个 transform 的输入。\r\n      transform: [\r\n        {\r\n          type: 'filter',\r\n          config: { dimension: 'Product', value: 'Tofu' }\r\n        },\r\n        {\r\n          type: 'sort',\r\n          config: { dimension: 'Year', order: 'desc' }\r\n        }\r\n      ]\r\n    }\r\n  ],\r\n  series: {\r\n    type: 'pie',\r\n    // 这个系列引用上述 transform 的结果。\r\n    datasetIndex: 1\r\n  }\r\n};\r\n```\r\n\r\n> 注意：理论上，任何 transform 都可能有多个输入或多个输出。但是，如果一个 transform 被链式声明，它只能获取前一个 transform 的第一个输出作为输入（第一个 transform 除外），以及它只能把自己的第一个输出给到后一个 transform （最后一个 transform 除外）。\r\n\r\n#### 一个 transform 输出多个 data\r\n\r\n在大多数场景下，transform 只需输出一个 data 。但是也有一些场景，需要输出多个 data ，每个 data 可以被不同的 series 或者 dataset 所使用。\r\n\r\n例如，在内置的 \"boxplot\" transform 中，除了 boxplot 系列所需要的 data 外，离群点（ outlier ）也会被生成，并且可以用例如散点图系列显示出来。例如，[example](${exampleEditorPath}boxplot-light-velocity)。\r\n\r\n我们提供配置 [dataset.fromTransformResult](${optionPath}#dataset.fromTransformResult) 来满足这种情况，例如：\r\n\r\n```js\r\noption = {\r\n  dataset: [\r\n    {\r\n      // 这个 dataset 的 index 为 `0`。\r\n      source: [\r\n        // 原始数据\r\n      ]\r\n    },\r\n    {\r\n      // 这个 dataset 的 index 为 `1`。\r\n      transform: {\r\n        type: 'boxplot'\r\n      }\r\n      // 这个 \"boxplot\" transform 生成了两个数据：\r\n      // result[0]: boxplot series 所需的数据。\r\n      // result[1]: 离群点数据。\r\n      // 当其他 series 或者 dataset 引用这个 dataset 时，他们默认只能得到\r\n      // result[0] 。\r\n      // 如果想要他们得到 result[1] ，需要额外声明如下这样一个 dataset ：\r\n    },\r\n    {\r\n      // 这个 dataset 的 index 为 `2`。\r\n      // 这个额外的 dataset 指定了数据来源于 index 为 `1` 的 dataset。\r\n      fromDatasetIndex: 1,\r\n      // 并且指定了获取 transform result[1] 。\r\n      fromTransformResult: 1\r\n    }\r\n  ],\r\n  xAxis: {\r\n    type: 'category'\r\n  },\r\n  yAxis: {},\r\n  series: [\r\n    {\r\n      name: 'boxplot',\r\n      type: 'boxplot',\r\n      // Reference the data from result[0].\r\n      // 这个 series 引用 index 为 `1` 的 dataset 。\r\n      datasetIndex: 1\r\n    },\r\n    {\r\n      name: 'outlier',\r\n      type: 'scatter',\r\n      // 这个 series 引用 index 为 `2` 的 dataset 。\r\n      // 从而也就得到了上述的 transform result[1] （即离群点数据）\r\n      datasetIndex: 2\r\n    }\r\n  ]\r\n};\r\n```\r\n\r\n另外，[dataset.fromTransformResult](${optionPath}#dataset.fromTransformResult) 和 [dataset.transform](${optionPath}#dataset.transform) 能同时出现在一个 dataset 中，这表示，这个 transform 的输入，是上游的结果中以 `fromTransformResult` 获取的结果。例如：\r\n\r\n```js\r\n{\r\n  fromDatasetIndex: 1,\r\n  fromTransformResult: 1,\r\n  transform: {\r\n    type: 'sort',\r\n    config: { dimension: 2, order: 'desc' }\r\n  }\r\n}\r\n```\r\n\r\n#### 在开发环境中 debug\r\n\r\n使用 transform 时，有时候我们会配不对，显示不出来结果，并且不知道哪里错了。所以，这里提供了一个配置项 `transform.print` 方便 debug 。这个配置项只在开发环境中生效。如下例：\r\n\r\n```js\r\noption = {\r\n  dataset: [\r\n    {\r\n      source: []\r\n    },\r\n    {\r\n      transform: {\r\n        type: 'filter',\r\n        config: {},\r\n        // 配置为 `true` 后， transform 的结果\r\n        // 会被 console.log 打印出来。\r\n        print: true\r\n      }\r\n    }\r\n  ]\r\n  // ...\r\n};\r\n```\r\n\r\n## 数据转换器 \"filter\"\r\n\r\necharts 内置提供了能起过滤作用的数据转换器。我们只需声明 `transform.type: \"filter\"`，以及给出数据筛选条件。如下例：\r\n\r\n```js live\r\noption = {\r\n  dataset: [\r\n    {\r\n      source: [\r\n        ['Product', 'Sales', 'Price', 'Year'],\r\n        ['Cake', 123, 32, 2011],\r\n        ['Latte', 231, 14, 2011],\r\n        ['Tofu', 235, 5, 2011],\r\n        ['Milk Tee', 341, 25, 2011],\r\n        ['Porridge', 122, 29, 2011],\r\n        ['Cake', 143, 30, 2012],\r\n        ['Latte', 201, 19, 2012],\r\n        ['Tofu', 255, 7, 2012],\r\n        ['Milk Tee', 241, 27, 2012],\r\n        ['Porridge', 102, 34, 2012],\r\n        ['Cake', 153, 28, 2013],\r\n        ['Latte', 181, 21, 2013],\r\n        ['Tofu', 395, 4, 2013],\r\n        ['Milk Tee', 281, 31, 2013],\r\n        ['Porridge', 92, 39, 2013],\r\n        ['Cake', 223, 29, 2014],\r\n        ['Latte', 211, 17, 2014],\r\n        ['Tofu', 345, 3, 2014],\r\n        ['Milk Tee', 211, 35, 2014],\r\n        ['Porridge', 72, 24, 2014]\r\n      ]\r\n    },\r\n    {\r\n      transform: {\r\n        type: 'filter',\r\n        config: { dimension: 'Year', '=': 2011 }\r\n        // 这个筛选条件表示，遍历数据，筛选出维度（ dimension ）\r\n        // 'Year' 上值为 2011 的所有数据项。\r\n      }\r\n    }\r\n  ],\r\n  series: {\r\n    type: 'pie',\r\n    datasetIndex: 1\r\n  }\r\n};\r\n```\r\n\r\n这是 filter 的另一个例子的效果：\r\n\r\n<md-example src=\"data-transform-filter\"></md-example>\r\n\r\n在 \"filter\" transform 中，有这些要素：\r\n\r\n**关于维度（ dimension ）：**\r\n\r\n`config.dimension` 指定了维度，能设成这样的值：\r\n\r\n- 设定成声明在 dataset 中的维度名，例如 `config: { dimension: 'Year', '=': 2011 }`。不过， dataset 中维度名的声明并非强制，所以我们也可以\r\n- 设定成 dataset 中的维度 index （index 值从 0 开始）例如 `config: { dimension: 3, '=': 2011 }`。\r\n\r\n**关于关系比较操作符：**\r\n\r\n关系操作符，可以设定这些：\r\n`>`（`gt`）、`>=`（`gte`）、`<`（`lt`）、`<=`（`lte`）、`=`（`eq`）、`!=`（`ne`、`<>`）、`reg`。（小括号中的符号或名字，是别名，设置起来作用相同）。他们首先基本地能基于数值大小进行比较，然后也有些额外的功能特性：\r\n\r\n- 多个关系操作符能声明在一个 {} 中，例如 `{ dimension: 'Price', '>=': 20, '<': 30 }`。这表示“与”的关系，即，筛选出价格大于等于 20 小于 30 的数据项。\r\n- data 里的值，不仅可以是数值（ number ），也可以是“类数值的字符串”（“ numeric string ”）。“类数值的字符串”本身是一个字符串，但是可以被转换为字面所描述的数值，例如 `' 123 '`。转换过程中，空格（全角半角空格）和换行符都能被消除（ trim ）。\r\n- 如果我们需要对日期对象（JS `Date`）或者日期字符串（如 '2012-05-12'）进行比较，我们需要手动指定 `parser: 'time'`，例如 `config: { dimension: 3, lt: '2012-05-12', parser: 'time' }`。\r\n- 纯字符串比较也被支持，但是只能用在 `=` 或 `!=` 上。而 `>`, `>=`, `<`, `<=` 并不支持纯字符串比较，也就是说，这四个操作符的右值，不能是字符串。\r\n- `reg` 操作符能提供正则表达式比较。例如， `{ dimension: 'Name', reg: /\\s+Müller\\s*$/ }` 能在 `'Name'` 维度上选出姓 `'Müller'` 的数据项。\r\n\r\n**关于逻辑比较：**\r\n\r\n我们也支持了逻辑比较操作符 **与或非**（ `and` | `or` | `not` ）：\r\n\r\n```js\r\noption = {\r\n  dataset: [\r\n    {\r\n      source: [\r\n        // ...\r\n      ]\r\n    },\r\n    {\r\n      transform: {\r\n        type: 'filter',\r\n        config: {\r\n          // 使用 and 操作符。\r\n          // 类似地，同样的位置也可以使用 “or” 或 “not”。\r\n          // 但是注意 “not” 后应该跟一个 {...} 而非 [...] 。\r\n          and: [\r\n            { dimension: 'Year', '=': 2011 },\r\n            { dimension: 'Price', '>=': 20, '<': 30 }\r\n          ]\r\n        }\r\n        // 这个表达的是，选出 2011 年价格大于等于 20 但小于 30 的数据项。\r\n      }\r\n    }\r\n  ],\r\n  series: {\r\n    type: 'pie',\r\n    datasetIndex: 1\r\n  }\r\n};\r\n```\r\n\r\n`and`/`or`/`not` 自然可以被嵌套，例如：\r\n\r\n```js\r\ntransform: {\r\n  type: 'filter',\r\n  config: {\r\n    or: [{\r\n      and: [{\r\n        dimension: 'Price', '>=': 10, '<': 20\r\n      }, {\r\n        dimension: 'Sales', '<': 100\r\n      }, {\r\n        not: { dimension: 'Product', '=': 'Tofu' }\r\n      }]\r\n    }, {\r\n      and: [{\r\n        dimension: 'Price', '>=': 10, '<': 20\r\n      }, {\r\n        dimension: 'Sales', '<': 100\r\n      }, {\r\n        not: { dimension: 'Product', '=': 'Cake' }\r\n      }]\r\n    }]\r\n  }\r\n}\r\n```\r\n\r\n**关于解析器（ parser ）：**\r\n\r\n还可以指定“解析器”（ parser ）来对值进行解析后再做比较。现在支持的解析器有：\r\n\r\n- `parser: 'time'`：把原始值解析成时间戳（ timestamp ）后再做比较。这个解析器的行为，和 `echarts.time.parse` 相同，即，当原始值为时间对象（ JS `Date` 实例），或者是时间戳，或者是描述时间的字符串（例如 `'2012-05-12 03:11:22'` ），都可以被解析为时间戳，然后就可以基于数值大小进行比较。如果原始数据是其他不可解析为时间戳的值，那么会被解析为 NaN。\r\n- `parser: 'trim'`：如果原始数据是字符串，则把字符串两端的空格（全角半角）和换行符去掉。如果不是字符串，还保持为原始数据。\r\n- `parser: 'number'`：强制把原始数据转成数值。如果不能转成有意义的数值，那么转成 `NaN`。在大多数场景下，我们并不需要这个解析器，因为按默认策略，“像数值的字符串”就会被转成数值。但是默认策略比较严格，这个解析器比较宽松，如果我们遇到含有尾缀的字符串（例如 `'33%'`, `12px`），我们需要手动指定 `parser: 'number'`，从而去掉尾缀转为数值才能比较。\r\n\r\n这个例子显示了如何使用 `parser: 'time'`：\r\n\r\n```js\r\noption = {\r\n  dataset: [\r\n    {\r\n      source: [\r\n        ['Product', 'Sales', 'Price', 'Date'],\r\n        ['Milk Tee', 311, 21, '2012-05-12'],\r\n        ['Cake', 135, 28, '2012-05-22'],\r\n        ['Latte', 262, 36, '2012-06-02'],\r\n        ['Milk Tee', 359, 21, '2012-06-22'],\r\n        ['Cake', 121, 28, '2012-07-02'],\r\n        ['Latte', 271, 36, '2012-06-22']\r\n        // ...\r\n      ]\r\n    },\r\n    {\r\n      transform: {\r\n        type: 'filter',\r\n        config: {\r\n          dimension: 'Date',\r\n          '>=': '2012-05',\r\n          '<': '2012-06',\r\n          parser: 'time'\r\n        }\r\n      }\r\n    }\r\n  ]\r\n};\r\n```\r\n\r\n**形式化定义：**\r\n\r\n最后，我们给出，数据转换器 \"filter\" 的 config 的形式化定义：\r\n\r\n```ts\r\ntype FilterTransform = {\r\n  type: 'filter';\r\n  config: ConditionalExpressionOption;\r\n};\r\ntype ConditionalExpressionOption =\r\n  | true\r\n  | false\r\n  | RelationalExpressionOption\r\n  | LogicalExpressionOption;\r\ntype RelationalExpressionOption = {\r\n  dimension: DimensionName | DimensionIndex;\r\n  parser?: 'time' | 'trim' | 'number';\r\n  lt?: DataValue; // less than\r\n  lte?: DataValue; // less than or equal\r\n  gt?: DataValue; // greater than\r\n  gte?: DataValue; // greater than or equal\r\n  eq?: DataValue; // equal\r\n  ne?: DataValue; // not equal\r\n  '<'?: DataValue; // lt\r\n  '<='?: DataValue; // lte\r\n  '>'?: DataValue; // gt\r\n  '>='?: DataValue; // gte\r\n  '='?: DataValue; // eq\r\n  '!='?: DataValue; // ne\r\n  '<>'?: DataValue; // ne (SQL style)\r\n  reg?: RegExp | string; // RegExp\r\n};\r\ntype LogicalExpressionOption = {\r\n  and?: ConditionalExpressionOption[];\r\n  or?: ConditionalExpressionOption[];\r\n  not?: ConditionalExpressionOption;\r\n};\r\ntype DataValue = string | number | Date;\r\ntype DimensionName = string;\r\ntype DimensionIndex = number;\r\n```\r\n\r\n> 注意：使用[按需引入](${lang}/basics/import#按需引入-echarts-图表和组件)接口时，如果需要使用该内置转换器，除了 `Dataset` 组件，还需引入 `Transform` 组件。\r\n\r\n```ts\r\nimport {\r\n  DatasetComponent,\r\n  TransformComponent\r\n} from 'echarts/components';\r\n\r\necharts.use([\r\n  DatasetComponent,\r\n  TransformComponent\r\n]);\r\n```\r\n\r\n## 数据转换器 \"sort\"\r\n\r\n\"sort\" 是另一个内置的数据转换器，用于排序数据。目前主要能用于在类目轴（ `axis.type: 'category'` ）中显示排过序的数据。例如：\r\n\r\n```js\r\noption = {\r\n  dataset: [\r\n    {\r\n      dimensions: ['name', 'age', 'profession', 'score', 'date'],\r\n      source: [\r\n        [' Hannah Krause ', 41, 'Engineer', 314, '2011-02-12'],\r\n        ['Zhao Qian ', 20, 'Teacher', 351, '2011-03-01'],\r\n        [' Jasmin Krause ', 52, 'Musician', 287, '2011-02-14'],\r\n        ['Li Lei', 37, 'Teacher', 219, '2011-02-18'],\r\n        [' Karle Neumann ', 25, 'Engineer', 253, '2011-04-02'],\r\n        [' Adrian Groß', 19, 'Teacher', null, '2011-01-16'],\r\n        ['Mia Neumann', 71, 'Engineer', 165, '2011-03-19'],\r\n        [' Böhm Fuchs', 36, 'Musician', 318, '2011-02-24'],\r\n        ['Han Meimei ', 67, 'Engineer', 366, '2011-03-12']\r\n      ]\r\n    },\r\n    {\r\n      transform: {\r\n        type: 'sort',\r\n        // 按分数排序\r\n        config: { dimension: 'score', order: 'asc' }\r\n      }\r\n    }\r\n  ],\r\n  series: {\r\n    type: 'bar',\r\n    datasetIndex: 1\r\n  }\r\n  // ...\r\n};\r\n```\r\n\r\n<md-example src=\"data-transform-sort-bar\"></md-example>\r\n\r\n数据转换器 \"sort\" 还有一些额外的功能：\r\n\r\n- 可以多重排序，多个维度一起排序。见下面的例子。\r\n- 排序规则是这样的：\r\n  - 默认按照数值大小排序。其中，“可转为数值的字符串”也被转换成数值，和其他数值一起按大小排序。\r\n  - 对于其他“不能转为数值的字符串”，也能在它们之间按字符串进行排序。这个特性有助于这种场景：把相同标签的数据项排到一起，尤其是当多个维度共同排序时。见下面的例子。\r\n  - 当“数值及可转为数值的字符串”和“不能转为数值的字符串”进行排序时，或者它们和“其他类型的值”进行比较时，它们本身是不知如何进行比较的。那么我们称呼“后者”为“incomparable”，并且可以设置 `incomparable: 'min' | 'max'` 来指定一个“incomparable”在这个比较中是最大还是最小，从而能使它们能产生比较结果。这个设定的用途，比如可以是，决定空值（例如 `null`, `undefined`, `NaN`, `''`, `'-'`）在排序的头还是尾。\r\n- 解析器 `parser: 'time' | 'trim' | 'number'` 可以被使用，和数据转换器 \"filter\" 中的情况一样。\r\n  - 如果要对时间进行排序（例如，值为 JS `Date` 实例或者时间字符串如 `'2012-03-12 11:13:54'`），我们需要声明 `parser: 'time'`。\r\n  - 如果需要对有后缀的数值进行排序（如 `'33%'`, `'16px'`）我们需要声明 `parser: 'number'`。\r\n\r\n这是一个“多维度排序”的例子。\r\n\r\n```js\r\noption = {\r\n  dataset: [\r\n    {\r\n      dimensions: ['name', 'age', 'profession', 'score', 'date'],\r\n      source: [\r\n        [' Hannah Krause ', 41, 'Engineer', 314, '2011-02-12'],\r\n        ['Zhao Qian ', 20, 'Teacher', 351, '2011-03-01'],\r\n        [' Jasmin Krause ', 52, 'Musician', 287, '2011-02-14'],\r\n        ['Li Lei', 37, 'Teacher', 219, '2011-02-18'],\r\n        [' Karle Neumann ', 25, 'Engineer', 253, '2011-04-02'],\r\n        [' Adrian Groß', 19, 'Teacher', null, '2011-01-16'],\r\n        ['Mia Neumann', 71, 'Engineer', 165, '2011-03-19'],\r\n        [' Böhm Fuchs', 36, 'Musician', 318, '2011-02-24'],\r\n        ['Han Meimei ', 67, 'Engineer', 366, '2011-03-12']\r\n      ]\r\n    },\r\n    {\r\n      transform: {\r\n        type: 'sort',\r\n        config: [\r\n          // 对两个维度按声明的优先级分别排序。\r\n          { dimension: 'profession', order: 'desc' },\r\n          { dimension: 'score', order: 'desc' }\r\n        ]\r\n      }\r\n    }\r\n  ],\r\n  series: {\r\n    type: 'bar',\r\n    datasetIndex: 1\r\n  }\r\n  //...\r\n};\r\n```\r\n\r\n<md-example src=\"doc-example/data-transform-multiple-sort-bar\"></md-example>\r\n\r\n最后，我们给出数据转换器 \"sort\" 的 config 的形式化定义。\r\n\r\n```ts\r\ntype SortTransform = {\r\n  type: 'sort';\r\n  config: OrderExpression | OrderExpression[];\r\n};\r\ntype OrderExpression = {\r\n  dimension: DimensionName | DimensionIndex;\r\n  order: 'asc' | 'desc';\r\n  incomparable?: 'min' | 'max';\r\n  parser?: 'time' | 'trim' | 'number';\r\n};\r\ntype DimensionName = string;\r\ntype DimensionIndex = number;\r\n```\r\n\r\n> 注意：使用[按需引入](${lang}/basics/import#按需引入-echarts-图表和组件)接口时，如果需要使用该内置转换器，除了 `Dataset` 组件，还需引入 `Transform` 组件。\r\n\r\n```ts\r\nimport {\r\n  DatasetComponent,\r\n  TransformComponent\r\n} from 'echarts/components';\r\n\r\necharts.use([\r\n  DatasetComponent,\r\n  TransformComponent\r\n]);\r\n```\r\n\r\n## 使用外部的数据转换器\r\n\r\n除了上述的内置的数据转换器外，我们也可以使用外部的数据转换器。外部数据转换器能提供或自己定制更丰富的功能。下面的例子中，我们使用第三方库 [ecStat](https://github.com/ecomfe/echarts-stat) 提供的数据转换器。\r\n\r\n生成数据的回归线：\r\n\r\n```js\r\n// 首先要注册外部数据转换器。\r\necharts.registerTransform(ecStatTransform(ecStat).regression);\r\n```\r\n\r\n```js\r\noption = {\r\n  dataset: [\r\n    {\r\n      source: rawData\r\n    },\r\n    {\r\n      transform: {\r\n        // 引用注册的数据转换器。\r\n        // 注意，每个外部的数据转换器，都有名空间（如 'ecStat:xxx'，'ecStat' 是名空间）。\r\n        // 而内置数据转换器（如 'filter', 'sort'）没有名空间。\r\n        type: 'ecStat:regression',\r\n        config: {\r\n          // 这里是此外部数据转换器所需的参数。\r\n          method: 'exponential'\r\n        }\r\n      }\r\n    }\r\n  ],\r\n  xAxis: { type: 'category' },\r\n  yAxis: {},\r\n  series: [\r\n    {\r\n      name: 'scatter',\r\n      type: 'scatter',\r\n      datasetIndex: 0\r\n    },\r\n    {\r\n      name: 'regression',\r\n      type: 'line',\r\n      symbol: 'none',\r\n      datasetIndex: 1\r\n    }\r\n  ]\r\n};\r\n```\r\n\r\n一些使用 echarts-stat 的例子：\r\n\r\n- [聚集 (Aggregate)](${exampleEditorPath}data-transform-aggregate&edit=1&reset=1)\r\n- [直方图 (Histogram)](${exampleEditorPath}bar-histogram&edit=1&reset=1)\r\n- [简单聚类 (Clustering)](${exampleEditorPath}scatter-clustering&edit=1&reset=1)\r\n- [线性回归线 (Linear Regression)](${exampleEditorPath}scatter-linear-regression&edit=1&reset=1)\r\n- [指数回归线 (Exponential Regression)](${exampleEditorPath}scatter-exponential-regression&edit=1&reset=1)\r\n- [对数回归线 (Logarithmic Regression)](${exampleEditorPath}scatter-logarithmic-regression&edit=1&reset=1)\r\n- [多项式回归线 (Polynomial Regression)](${exampleEditorPath}scatter-polynomial-regression&edit=1&reset=1)\r\n"}}]);